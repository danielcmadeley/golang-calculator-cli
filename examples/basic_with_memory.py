#!/usr/bin/env python3
"""
Basic Calculator with Memory
A basic calculator with essential arithmetic operations

Generated by Calculator Generator
Author: Demo User
Version: 1.0.0
Generated: 2025-07-20 15:49:29
"""

import sys
import os
import math
import json
from datetime import datetime



def add(a, b):
    """Addition operation"""
    return a + b


def subtract(a, b):
    """Subtraction operation"""
    return a - b


def multiply(a, b):
    """Multiplication operation"""
    return a * b


def divide(a, b):
    """Division operation"""
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return a / b


def power(a, b):
    """Power operation"""
    return a ** b


def modulo(a, b):
    """Modulo operation"""
    if b == 0:
        raise ValueError("Cannot calculate modulo with zero")
    return a % b


class Memory:
    """Calculator memory functionality"""
    def __init__(self):
        self.value = 0

    def store(self, value):
        """Store value in memory"""
        self.value = value
        return f"Stored {value} in memory"

    def recall(self):
        """Recall value from memory"""
        return self.value

    def clear(self):
        """Clear memory"""
        self.value = 0
        return "Memory cleared"

    def add_to_memory(self, value):
        """Add value to memory"""
        self.value += value
        return f"Added {value} to memory, new value: {self.value}"


class History:
    """Calculator history functionality"""
    def __init__(self, max_entries=100):
        self.entries = []
        self.max_entries = max_entries

    def add_entry(self, operation, result):
        """Add calculation to history"""
        entry = {
            "timestamp": datetime.now().isoformat(),
            "operation": operation,
            "result": result
        }
        self.entries.append(entry)

        # Keep only max_entries
        if len(self.entries) > self.max_entries:
            self.entries = self.entries[-self.max_entries:]

    def get_history(self, count=10):
        """Get recent history entries"""
        return self.entries[-count:]

    def clear_history(self):
        """Clear calculation history"""
        self.entries = []
        return "History cleared"

    def save_to_file(self, filename="calculator_history.json"):
        """Save history to file"""
        with open(filename, 'w') as f:
            json.dump(self.entries, f, indent=2)
        return f"History saved to {filename}"



class Calculator:
    """Main calculator class"""

    def __init__(self):
        self.precision = 10
        self.angle_unit = "degrees"
        self.memory = Memory()
        self.history = History()

    def format_result(self, result):
        """Format calculation result"""
        if isinstance(result, (int, float)):
            return round(result, self.precision)
        return result

    def run(self):
        """Run the calculator interface"""
        self.show_banner()
        self.interactive_mode()

    def interactive_mode(self):
        """Interactive calculator mode"""
        print("Calculator started. Type 'help' for commands, 'quit' to exit.")

        while True:
            try:
                user_input = input("calc> ").strip()

                if user_input.lower() in ['quit', 'exit', 'q']:
                    break
                elif user_input.lower() == 'help':
                    self.show_help()
                elif user_input.lower() == 'clear':
                    os.system('cls' if os.name == 'nt' else 'clear')
                elif user_input.lower().startswith('mem'):
                    self.handle_memory_commands(user_input)
                elif user_input.lower().startswith('hist'):
                    self.handle_history_commands(user_input)
                else:
                    result = self.evaluate_expression(user_input)
                    formatted_result = self.format_result(result)
                    print(f"Result: {formatted_result}")
                    self.history.add_entry(user_input, formatted_result)

            except KeyboardInterrupt:
                print("\nGoodbye!")
                break
            except Exception as e:
                print(f"Error: {e}")

    def show_banner(self):
        """Display calculator banner"""
        print("="*50)
        print(f"  {self.config.ProjectName}")
        print(f"  {self.config.Description}")
        print("="*50)

    def show_help(self):
        """Display help information"""
        help_text = """
Available commands:
  Basic operations: +, -, *, /, **, %
  Functions: sin(), cos(), tan(), log(), ln(), sqrt()
  Memory: mem store <value>, mem recall, mem clear
  History: hist show, hist clear, hist save
  Other: help, clear, quit
        """
        print(help_text)

    def evaluate_expression(self, expression):
        """Evaluate mathematical expression"""
        # Basic expression evaluation
        try:
            # Replace common functions
            expression = expression.replace('^', '**')
            
            # Add math functions to evaluation context
            safe_dict = {
                "__builtins__": {},
                "abs": abs, "round": round, "min": min, "max": max,
                "sin": lambda x: sin(x, self.angle_unit),
                "cos": lambda x: cos(x, self.angle_unit),
                "tan": lambda x: tan(x, self.angle_unit),
                "sqrt": math.sqrt, "log": log, "ln": ln,
                "pi": math.pi, "e": math.e
            }

            return eval(expression, safe_dict)
        except Exception as e:
            raise ValueError(f"Invalid expression: {e}")

    def handle_memory_commands(self, command):
        """Handle memory-related commands"""
        parts = command.split()
        if len(parts) < 2:
            print("Memory commands: mem store <value>, mem recall, mem clear")
            return

        action = parts[1].lower()
        if action == "store" and len(parts) > 2:
            try:
                value = float(parts[2])
                print(self.memory.store(value))
            except ValueError:
                print("Invalid value for memory storage")
        elif action == "recall":
            print(f"Memory: {self.memory.recall()}")
        elif action == "clear":
            print(self.memory.clear())
        else:
            print("Unknown memory command")

    def handle_history_commands(self, command):
        """Handle history-related commands"""
        parts = command.split()
        if len(parts) < 2:
            print("History commands: hist show, hist clear, hist save")
            return

        action = parts[1].lower()
        if action == "show":
            count = 10
            if len(parts) > 2:
                try:
                    count = int(parts[2])
                except ValueError:
                    pass
            history = self.history.get_history(count)
            for entry in history:
                print(f"{entry['timestamp']}: {entry['operation']} = {entry['result']}")
        elif action == "clear":
            print(self.history.clear_history())
        elif action == "save":
            filename = "calculator_history.json"
            if len(parts) > 2:
                filename = parts[2]
            print(self.history.save_to_file(filename))
        else:
            print("Unknown history command")


if __name__ == "__main__":
    calculator = Calculator()
    calculator.run()
