#!/usr/bin/env python3
"""
Scientific Graphing Calculator
A scientific calculator with advanced mathematical functions

Generated by Calculator Generator
Author: Calculator Generator
Version: 1.0.0
Generated: 2025-07-20 15:49:35
"""

import sys
import os
import math
import numpy as np
import plotly.graph_objects as go
import plotly.express as px



def add(a, b):
    """Addition operation"""
    return a + b


def subtract(a, b):
    """Subtraction operation"""
    return a - b


def multiply(a, b):
    """Multiplication operation"""
    return a * b


def divide(a, b):
    """Division operation"""
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return a / b


def power(a, b):
    """Power operation"""
    return a ** b


def modulo(a, b):
    """Modulo operation"""
    if b == 0:
        raise ValueError("Cannot calculate modulo with zero")
    return a % b


def sin(x, angle_unit="degrees"):
    """Sine function"""
    if angle_unit == "degrees":
        x = math.radians(x)
    return math.sin(x)


def cos(x, angle_unit="degrees"):
    """Cosine function"""
    if angle_unit == "degrees":
        x = math.radians(x)
    return math.cos(x)


def tan(x, angle_unit="degrees"):
    """Tangent function"""
    if angle_unit == "degrees":
        x = math.radians(x)
    return math.tan(x)


def asin(x, angle_unit="degrees"):
    """Arcsine function"""
    result = math.asin(x)
    if angle_unit == "degrees":
        result = math.degrees(result)
    return result


def acos(x, angle_unit="degrees"):
    """Arccosine function"""
    result = math.acos(x)
    if angle_unit == "degrees":
        result = math.degrees(result)
    return result


def atan(x, angle_unit="degrees"):
    """Arctangent function"""
    result = math.atan(x)
    if angle_unit == "degrees":
        result = math.degrees(result)
    return result


def log(x, base=10):
    """Logarithm function"""
    if x <= 0:
        raise ValueError("Logarithm input must be positive")
    if base == math.e:
        return math.log(x)
    return math.log(x, base)


def ln(x):
    """Natural logarithm"""
    if x <= 0:
        raise ValueError("Natural logarithm input must be positive")
    return math.log(x)


def log10(x):
    """Base-10 logarithm"""
    if x <= 0:
        raise ValueError("Logarithm input must be positive")
    return math.log10(x)


def log2(x):
    """Base-2 logarithm"""
    if x <= 0:
        raise ValueError("Logarithm input must be positive")
    return math.log2(x)


def mean(data):
    """Calculate mean of data"""
    return np.mean(data)


def median(data):
    """Calculate median of data"""
    return np.median(data)


def std(data):
    """Calculate standard deviation"""
    return np.std(data)


def variance(data):
    """Calculate variance"""
    return np.var(data)


def correlation(x, y):
    """Calculate correlation coefficient"""
    return np.corrcoef(x, y)[0, 1]


def plot_function(func_str, x_range=(-10, 10), num_points=100):
    """Plot a mathematical function"""
    x = np.linspace(x_range[0], x_range[1], num_points)
    y = eval(func_str.replace('x', 'x'))

    fig = go.Figure()
    fig.add_trace(go.Scatter(x=x, y=y, mode='lines', name=func_str))
    fig.update_layout(title=f"Plot of {func_str}", xaxis_title="x", yaxis_title="y")
    fig.show()


def plot_data(x_data, y_data, title="Data Plot"):
    """Plot data points"""
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=x_data, y=y_data, mode='markers+lines'))
    fig.update_layout(title=title, xaxis_title="x", yaxis_title="y")
    fig.show()



class Calculator:
    """Main calculator class"""

    def __init__(self):
        self.precision = 15
        self.angle_unit = "radians"

    def format_result(self, result):
        """Format calculation result"""
        if isinstance(result, (int, float)):
            return round(result, self.precision)
        return result

    def run(self):
        """Run the calculator interface"""
        self.show_banner()
        self.interactive_mode()

    def interactive_mode(self):
        """Interactive calculator mode"""
        print("Calculator started. Type 'help' for commands, 'quit' to exit.")

        while True:
            try:
                user_input = input("calc> ").strip()

                if user_input.lower() in ['quit', 'exit', 'q']:
                    break
                elif user_input.lower() == 'help':
                    self.show_help()
                elif user_input.lower() == 'clear':
                    os.system('cls' if os.name == 'nt' else 'clear')
                else:
                    result = self.evaluate_expression(user_input)
                    formatted_result = self.format_result(result)
                    print(f"Result: {formatted_result}")

            except KeyboardInterrupt:
                print("\nGoodbye!")
                break
            except Exception as e:
                print(f"Error: {e}")

    def show_banner(self):
        """Display calculator banner"""
        print("="*50)
        print(f"  {self.config.ProjectName}")
        print(f"  {self.config.Description}")
        print("="*50)

    def show_help(self):
        """Display help information"""
        help_text = """
Available commands:
  Basic operations: +, -, *, /, **, %
  Functions: sin(), cos(), tan(), log(), ln(), sqrt()
  Other: help, clear, quit
        """
        print(help_text)

    def evaluate_expression(self, expression):
        """Evaluate mathematical expression"""
        # Basic expression evaluation
        try:
            # Replace common functions
            expression = expression.replace('^', '**')
            
            # Add math functions to evaluation context
            safe_dict = {
                "__builtins__": {},
                "abs": abs, "round": round, "min": min, "max": max,
                "sin": lambda x: sin(x, self.angle_unit),
                "cos": lambda x: cos(x, self.angle_unit),
                "tan": lambda x: tan(x, self.angle_unit),
                "sqrt": math.sqrt, "log": log, "ln": ln,
                "pi": math.pi, "e": math.e
            }
            safe_dict.update({
                "np": np, "array": np.array, "mean": mean,
                "median": median, "std": std
            })

            return eval(expression, safe_dict)
        except Exception as e:
            raise ValueError(f"Invalid expression: {e}")


if __name__ == "__main__":
    calculator = Calculator()
    calculator.run()
